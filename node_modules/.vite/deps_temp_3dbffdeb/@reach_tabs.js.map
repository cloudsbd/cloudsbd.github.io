{
  "version": 3,
  "sources": ["../../../../../node_modules/warning/warning.js", "../../../../../node_modules/@reach/utils/src/index.tsx", "../../../../../node_modules/@reach/descendants/src/index.tsx", "../../../../../node_modules/@reach/auto-id/src/index.ts", "../../../../../node_modules/@reach/tabs/src/index.tsx"],
  "sourcesContent": ["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 1 ? len - 1 : 0);\n    for (var key = 1; key < len; key++) {\n      args[key - 1] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n", "/* eslint-disable no-restricted-globals, eqeqeq  */\n\nimport React, {\n  cloneElement,\n  createContext,\n  isValidElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport warning from \"warning\";\nimport {\n  As,\n  AssignableRef,\n  ComponentWithAs,\n  ComponentWithForwardedRef,\n  DistributiveOmit,\n  ElementByTag,\n  ElementTagNameMap,\n  ForwardRefExoticComponentWithAs,\n  ForwardRefWithAsRenderFunction,\n  FunctionComponentWithAs,\n  MemoExoticComponentWithAs,\n  PropsFromAs,\n  PropsWithAs,\n  SingleOrArray,\n  ThenArg,\n} from \"./types\";\n\n/**\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect in the browser. We occasionally need useLayoutEffect to\n * ensure we don't get a render flash for certain operations, but we may also\n * need affected components to render on the server. One example is when setting\n * a component's descendants to retrieve their index values.\n *\n * Important to note that using this hook as an escape hatch will break the\n * eslint dependency warnings unless you rename the import to `useLayoutEffect`.\n * Use sparingly only when the effect won't effect the rendered HTML to avoid\n * any server/client mismatch.\n *\n * If a useLayoutEffect is needed and the result would create a mismatch, it's\n * likely that the component in question shouldn't be rendered on the server at\n * all, so a better approach would be to lazily render those in a parent\n * component after client-side hydration.\n *\n * TODO: We are calling useLayoutEffect in a couple of places that will likely\n * cause some issues for SSR users, whether the warning shows or not. Audit and\n * fix these.\n *\n * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\n * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js\n *\n * @param effect\n * @param deps\n */\nexport const useIsomorphicLayoutEffect = canUseDOM()\n  ? React.useLayoutEffect\n  : React.useEffect;\n\nlet checkedPkgs: { [key: string]: boolean } = {};\n\n/**\n * Copy of Facebook's warning package.\n */\nexport { warning };\n\n/**\n * When in dev mode, checks that styles for a given @reach package are loaded.\n *\n * @param packageName Name of the package to check.\n * @example checkStyles(\"dialog\") will check for styles for @reach/dialog\n */\n// @ts-ignore\nlet checkStyles: (packageName: string) => void = noop;\n\nif (__DEV__) {\n  // In CJS files, process.env.NODE_ENV is stripped from our build, but we need\n  // it to prevent style checks from clogging up user logs while testing.\n  // This is a workaround until we can tweak the build a bit to accommodate.\n  let { env } =\n    typeof process !== \"undefined\"\n      ? process\n      : { env: { NODE_ENV: \"development\" } };\n\n  checkStyles = function checkStyles(packageName: string) {\n    // only check once per package\n    if (checkedPkgs[packageName]) return;\n    checkedPkgs[packageName] = true;\n\n    if (\n      env.NODE_ENV !== \"test\" &&\n      parseInt(\n        window\n          .getComputedStyle(document.body)\n          .getPropertyValue(`--reach-${packageName}`),\n        10\n      ) !== 1\n    ) {\n      console.warn(\n        `@reach/${packageName} styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\n\n    import \"@reach/${packageName}/styles.css\";\n\n  Otherwise you'll need to include them some other way:\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"node_modules/@reach/${packageName}/styles.css\" />\n\n  For more information visit https://ui.reach.tech/styling.\n  `\n      );\n    }\n  };\n}\n\nexport { checkStyles };\n\n/**\n * Ponyfill for the global object in some environments.\n *\n * @link https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n */\nexport const ponyfillGlobal =\n  typeof window != \"undefined\" && window.Math == Math\n    ? window\n    : typeof self != \"undefined\" && self.Math == Math\n    ? self\n    : // eslint-disable-next-line no-new-func\n      Function(\"return this\")();\n\n/**\n * Passes or assigns an arbitrary value to a ref function or object.\n *\n * @param ref\n * @param value\n */\nexport function assignRef<RefValueType = any>(\n  ref: AssignableRef<RefValueType> | null | undefined,\n  value: any\n) {\n  if (ref == null) return;\n  if (isFunction(ref)) {\n    ref(value);\n  } else {\n    try {\n      ref.current = value;\n    } catch (error) {\n      throw new Error(`Cannot assign value \"${value}\" to ref \"${ref}\"`);\n    }\n  }\n}\n\n/**\n * Checks true|\"true\" vs false|\"false\"\n *\n * @param value\n */\nexport function boolOrBoolString(value: any): value is \"true\" | true {\n  return value === \"true\" ? true : isBoolean(value) ? value : false;\n}\n\nexport function canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  );\n}\n\n/**\n * Type-safe clone element\n *\n * @param element\n * @param props\n * @param children\n */\nexport function cloneValidElement<Props>(\n  element: React.ReactElement<Props> | React.ReactNode,\n  props?: Partial<Props> & React.Attributes,\n  ...children: React.ReactNode[]\n): React.ReactElement<Props> | React.ReactNode {\n  return isValidElement(element)\n    ? cloneElement(element, props, ...children)\n    : element;\n}\n\nexport function createNamedContext<ContextValueType>(\n  name: string,\n  defaultValue: ContextValueType\n): React.Context<ContextValueType> {\n  const Ctx = createContext<ContextValueType>(defaultValue);\n  Ctx.displayName = name;\n  return Ctx;\n}\n\n/**\n * This is a hack for sure. The thing is, getting a component to intelligently\n * infer props based on a component or JSX string passed into an `as` prop is\n * kind of a huge pain. Getting it to work and satisfy the constraints of\n * `forwardRef` seems dang near impossible. To avoid needing to do this awkward\n * type song-and-dance every time we want to forward a ref into a component\n * that accepts an `as` prop, we abstract all of that mess to this function for\n * the time time being.\n */\nexport function forwardRefWithAs<Props, ComponentType extends As = \"div\">(\n  render: ForwardRefWithAsRenderFunction<ComponentType, Props>\n) {\n  return React.forwardRef(render) as ForwardRefExoticComponentWithAs<\n    ComponentType,\n    Props\n  >;\n}\n\nexport function memoWithAs<Props, ComponentType extends As = \"div\">(\n  Component: FunctionComponentWithAs<ComponentType, Props>,\n  propsAreEqual?: (\n    prevProps: Readonly<React.PropsWithChildren<Props>>,\n    nextProps: Readonly<React.PropsWithChildren<Props>>\n  ) => boolean\n) {\n  return React.memo(Component, propsAreEqual) as MemoExoticComponentWithAs<\n    ComponentType,\n    Props\n  >;\n}\n\n/**\n * Get the size of the working document minus the scrollbar offset.\n *\n * @param element\n */\nexport function getDocumentDimensions(\n  element?: HTMLElement | null | undefined\n) {\n  if (!canUseDOM()) return { width: 0, height: 0 };\n  let doc = element ? getOwnerDocument(element)! : document;\n  let win = element ? getOwnerWindow(element)! : window;\n  return {\n    width: doc.documentElement.clientWidth || win.innerWidth,\n    height: doc.documentElement.clientHeight || win.innerHeight,\n  };\n}\n\n/**\n * Get the scoll position of the global window object relative to a given node.\n *\n * @param element\n */\nexport function getScrollPosition(element?: HTMLElement | null | undefined) {\n  if (!canUseDOM()) return { scrollX: 0, scrollY: 0 };\n  let win = element ? getOwnerWindow(element)! : window;\n  return {\n    scrollX: win.scrollX,\n    scrollY: win.scrollY,\n  };\n}\n\n/**\n * Get a computed style value by property, backwards compatible with IE\n * @param element\n * @param styleProp\n */\nexport function getElementComputedStyle(\n  element: HTMLElement & {\n    currentStyle?: Record<string, string>;\n  },\n  styleProp: string\n) {\n  let y: string | null = null;\n  let doc = getOwnerDocument(element);\n  if (element.currentStyle) {\n    y = element.currentStyle[styleProp];\n  } else if (\n    doc &&\n    doc.defaultView &&\n    isFunction(doc.defaultView.getComputedStyle)\n  ) {\n    y = doc.defaultView\n      .getComputedStyle(element, null)\n      .getPropertyValue(styleProp);\n  }\n  return y;\n}\n\n/**\n * Get an element's owner document. Useful when components are used in iframes\n * or other environments like dev tools.\n *\n * @param element\n */\nexport function getOwnerDocument<T extends HTMLElement = HTMLElement>(\n  element: T | null\n) {\n  return element && element.ownerDocument\n    ? element.ownerDocument\n    : canUseDOM()\n    ? document\n    : null;\n}\n\nexport function getOwnerWindow<T extends HTMLElement = HTMLElement>(\n  element: T | null\n) {\n  let doc = element ? getOwnerDocument(element) : null;\n  return doc ? doc.defaultView || window : null;\n}\n\n/**\n * Get the scrollbar offset distance.\n *\n * TODO: Remove in 1.0 (we used this in public examples)\n */\nexport function getScrollbarOffset() {\n  try {\n    if (window.innerWidth > document.documentElement.clientWidth) {\n      return window.innerWidth - document.documentElement.clientWidth;\n    }\n  } catch (err) {}\n  return 0;\n}\n\n/**\n * Checks whether or not a value is a boolean.\n *\n * @param value\n */\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === \"boolean\";\n}\n\n/**\n * Checks whether or not a value is a function.\n *\n * @param value\n */\nexport function isFunction(value: any): value is Function {\n  return !!(value && {}.toString.call(value) == \"[object Function]\");\n}\n\n/**\n * Checks whether or not a value is a number.\n *\n * @param value\n */\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\";\n}\n\n/**\n * Detects right clicks\n *\n * @param nativeEvent\n */\nexport function isRightClick(nativeEvent: MouseEvent) {\n  return nativeEvent.which === 3 || nativeEvent.button === 2;\n}\n\n/**\n * Checks whether or not a value is a string.\n *\n * @param value\n */\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\n/**\n * Joins strings to format IDs for compound components.\n *\n * @param args\n */\nexport function makeId(...args: (string | number | null | undefined)[]) {\n  return args.filter((val) => val != null).join(\"--\");\n}\n\n/**\n * No-op function.\n */\nexport function noop(): void {}\n\n/**\n * Convert our state strings for HTML data attributes.\n * No need for a fancy kebab-caser here, we know what our state strings are!\n *\n * @param state\n */\nexport function stateToAttributeString(state: any) {\n  return String(state)\n    .replace(/([\\s_]+)/g, \"-\")\n    .toLowerCase();\n}\n\n/**\n * Check if a component is controlled or uncontrolled and return the correct\n * state value and setter accordingly. If the component state is controlled by\n * the app, the setter is a noop.\n *\n * @param controlledValue\n * @param defaultValue\n */\nexport function useControlledState<T = any>(\n  controlledValue: T | undefined,\n  defaultValue: T\n): [T, React.Dispatch<React.SetStateAction<T>>] {\n  let controlledRef = useRef(controlledValue != null);\n  let [valueState, setValue] = useState(defaultValue);\n  let set: React.Dispatch<React.SetStateAction<T>> = useCallback((n) => {\n    if (!controlledRef.current) {\n      setValue(n);\n    }\n  }, []);\n  return [controlledRef.current ? (controlledValue as T) : valueState, set];\n}\n\n/**\n * Logs a warning in dev mode when a component switches from controlled to\n * uncontrolled, or vice versa\n *\n * A single prop should typically be used to determine whether or not a\n * component is controlled or not.\n *\n * @param controlledValue\n * @param controlledPropName\n * @param componentName\n */\nlet useControlledSwitchWarning: (\n  controlledValue: any,\n  controlledPropName: string,\n  componentName: string\n) => void = noop;\n\nif (__DEV__) {\n  useControlledSwitchWarning = function useControlledSwitchWarning(\n    controlledValue,\n    controlledPropName,\n    componentName\n  ) {\n    let controlledRef = useRef(controlledValue != null);\n    let nameCache = useRef({ componentName, controlledPropName });\n    useEffect(() => {\n      nameCache.current = { componentName, controlledPropName };\n    }, [componentName, controlledPropName]);\n\n    useEffect(() => {\n      let { current: wasControlled } = controlledRef;\n      let { componentName, controlledPropName } = nameCache.current;\n      let isControlled = controlledValue != null;\n      if (wasControlled !== isControlled) {\n        console.error(\n          `A component is changing an ${\n            wasControlled ? \"\" : \"un\"\n          }controlled \\`${controlledPropName}\\` state of ${componentName} to be ${\n            wasControlled ? \"un\" : \"\"\n          }controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled ${componentName} element for the lifetime of the component.\nMore info: https://fb.me/react-controlled-components`\n        );\n      }\n    }, [controlledValue]);\n  };\n}\n\nexport { useControlledSwitchWarning };\n\nlet useCheckStyles: (packageName: string) => void = noop;\n\nif (__DEV__) {\n  useCheckStyles = function useCheckStyles(pkg: string) {\n    let name = useRef(pkg);\n    useEffect(() => void (name.current = pkg), [pkg]);\n    useEffect(() => checkStyles(name.current), []);\n  };\n}\n\nexport { useCheckStyles };\n\n/**\n * React hook for creating a value exactly once.\n * @see https://github.com/Andarist/use-constant\n */\nexport function useConstant<ValueType>(fn: () => ValueType): ValueType {\n  const ref = React.useRef<{ v: ValueType }>();\n  if (!ref.current) {\n    ref.current = { v: fn() };\n  }\n  return ref.current.v;\n}\n\n/**\n * @param callback\n */\nexport function useEventCallback<E extends Event | React.SyntheticEvent>(\n  callback: (event: E, ...args: any[]) => void\n) {\n  const ref = useRef(callback);\n  useIsomorphicLayoutEffect(() => {\n    ref.current = callback;\n  });\n  return useCallback(\n    (event: E, ...args: any[]) => ref.current(event, ...args),\n    []\n  );\n}\n\n/**\n * @param callback\n */\nexport function useCallbackProp<F extends Function>(callback: F | undefined) {\n  const ref = useRef(callback);\n  useEffect(() => {\n    ref.current = callback;\n  });\n  return (useCallback(\n    (...args: any[]) => ref.current && ref.current(...args),\n    []\n  ) as unknown) as F;\n}\n\n/**\n * Adds a DOM event listener\n *\n * @param eventName\n * @param listener\n * @param element\n */\nexport function useEventListener<K extends keyof WindowEventMap>(\n  eventName: K,\n  listener: (event: WindowEventMap[K]) => any,\n  element: HTMLElement | Document | Window | EventTarget = window\n) {\n  const savedHandler = useRef(listener);\n  useEffect(() => {\n    savedHandler.current = listener;\n  }, [listener]);\n\n  useEffect(() => {\n    const isSupported = element && element.addEventListener;\n    if (!isSupported) {\n      if (__DEV__) {\n        console.warn(\"Event listener not supported on the element provided\");\n      }\n      return;\n    }\n\n    function eventListener(event: WindowEventMap[K]) {\n      savedHandler.current(event);\n    }\n\n    element.addEventListener(eventName, eventListener as any);\n    return () => {\n      element.removeEventListener(eventName, eventListener as any);\n    };\n  }, [eventName, element]);\n}\n\n/**\n * Detect when focus changes in our document.\n *\n * @param handleChange\n * @param when\n * @param ownerDocument\n */\nexport function useFocusChange(\n  handleChange: (\n    activeElement: Element | null,\n    previousActiveElement: Element | null,\n    event?: FocusEvent\n  ) => void = console.log,\n  when: \"focus\" | \"blur\" = \"focus\",\n  ownerDocument: Document = document\n) {\n  let lastActiveElement = useRef(ownerDocument.activeElement);\n\n  useEffect(() => {\n    lastActiveElement.current = ownerDocument.activeElement;\n\n    function onChange(event: FocusEvent) {\n      if (lastActiveElement.current !== ownerDocument.activeElement) {\n        handleChange(\n          ownerDocument.activeElement,\n          lastActiveElement.current,\n          event\n        );\n        lastActiveElement.current = ownerDocument.activeElement;\n      }\n    }\n\n    ownerDocument.addEventListener(when, onChange, true);\n\n    return () => {\n      ownerDocument.removeEventListener(when, onChange);\n    };\n  }, [when, handleChange, ownerDocument]);\n}\n\n/**\n * Passes or assigns a value to multiple refs (typically a DOM node). Useful for\n * dealing with components that need an explicit ref for DOM calculations but\n * also forwards refs assigned by an app.\n *\n * @param refs Refs to fork\n */\nexport function useForkedRef<RefValueType = any>(\n  ...refs: (AssignableRef<RefValueType> | null | undefined)[]\n) {\n  return useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (node: any) => {\n      refs.forEach((ref) => {\n        assignRef(ref, node);\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [...refs]);\n}\n\n/**\n * Returns the previous value of a reference after a component update.\n *\n * @param value\n */\nexport function usePrevious<ValueType = any>(value: ValueType) {\n  const ref = useRef<ValueType | null>(null);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\n/**\n * Call an effect after a component update, skipping the initial mount.\n *\n * @param effect Effect to call\n * @param deps Effect dependency list\n */\nexport function useUpdateEffect(\n  effect: React.EffectCallback,\n  deps?: React.DependencyList\n) {\n  const mounted = useRef(false);\n  useEffect(() => {\n    if (mounted.current) {\n      effect();\n    } else {\n      mounted.current = true;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n\n/**\n * Just a lil state logger\n *\n * @param state\n * @param DEBUG\n */\nlet useStateLogger: (state: string, DEBUG: boolean) => void = noop;\n\nif (__DEV__) {\n  useStateLogger = function useStateLogger(state, DEBUG = false) {\n    let debugRef = useRef(DEBUG);\n    useEffect(() => {\n      debugRef.current = DEBUG;\n    }, [DEBUG]);\n    useEffect(() => {\n      if (debugRef.current) {\n        console.group(\"State Updated\");\n        console.log(\n          \"%c\" + state,\n          \"font-weight: normal; font-size: 120%; font-style: italic;\"\n        );\n        console.groupEnd();\n      }\n    }, [state]);\n  };\n}\n\nexport { useStateLogger };\n\n/**\n * Wraps a lib-defined event handler and a user-defined event handler, returning\n * a single handler that allows a user to prevent lib-defined handlers from\n * firing.\n *\n * @param theirHandler User-supplied event handler\n * @param ourHandler Library-supplied event handler\n */\nexport function wrapEvent<EventType extends React.SyntheticEvent | Event>(\n  theirHandler: ((event: EventType) => any) | undefined,\n  ourHandler: (event: EventType) => any\n): (event: EventType) => any {\n  return (event) => {\n    theirHandler && theirHandler(event);\n    if (!event.defaultPrevented) {\n      return ourHandler(event);\n    }\n  };\n}\n\n// Export types\nexport {\n  As,\n  AssignableRef,\n  ComponentWithAs,\n  ComponentWithForwardedRef,\n  DistributiveOmit,\n  ElementByTag,\n  ElementTagNameMap,\n  ForwardRefExoticComponentWithAs,\n  FunctionComponentWithAs,\n  MemoExoticComponentWithAs,\n  PropsFromAs,\n  PropsWithAs,\n  SingleOrArray,\n  ThenArg,\n};\n", "import React, { useCallback, useContext, useMemo, useState } from \"react\";\nimport {\n  createNamedContext,\n  noop,\n  useIsomorphicLayoutEffect,\n  usePrevious,\n} from \"@reach/utils\";\n\nexport function createDescendantContext<DescendantType extends Descendant>(\n  name: string,\n  initialValue = {}\n) {\n  type T = DescendantContextValue<DescendantType>;\n  const descendants: DescendantType[] = [];\n  return createNamedContext<T>(name, {\n    descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop,\n    ...initialValue,\n  });\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nexport function useDescendant<DescendantType extends Descendant>(\n  descendant: Omit<DescendantType, \"index\">,\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  indexProp?: number\n) {\n  let [, forceUpdate] = useState();\n  let { registerDescendant, unregisterDescendant, descendants } = useContext(\n    context\n  );\n\n  // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n  let index =\n    indexProp ??\n    descendants.findIndex((item) => item.element === descendant.element);\n\n  let previousDescendants = usePrevious(descendants);\n\n  // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n  let someDescendantsHaveChanged = descendants.some((descendant, index) => {\n    return descendant.element !== previousDescendants?.[index]?.element;\n  });\n\n  // Prevent any flashing\n  useIsomorphicLayoutEffect(() => {\n    if (!descendant.element) forceUpdate({});\n    registerDescendant({\n      ...descendant,\n      index,\n    } as DescendantType);\n    return () => unregisterDescendant(descendant.element);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    registerDescendant,\n    unregisterDescendant,\n    index,\n    someDescendantsHaveChanged,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    ...Object.values(descendant),\n  ]);\n\n  return index;\n}\n\nexport function useDescendantsInit<DescendantType extends Descendant>() {\n  return useState<DescendantType[]>([]);\n}\n\nexport function useDescendants<DescendantType extends Descendant>(\n  ctx: React.Context<DescendantContextValue<DescendantType>>\n) {\n  return useContext(ctx).descendants;\n}\n\nexport function DescendantProvider<DescendantType extends Descendant>({\n  context: Ctx,\n  children,\n  items,\n  set,\n}: {\n  context: React.Context<DescendantContextValue<DescendantType>>;\n  children: React.ReactNode;\n  items: DescendantType[];\n  set: React.Dispatch<React.SetStateAction<DescendantType[]>>;\n}) {\n  let registerDescendant = useCallback(\n    ({\n      element,\n      index: explicitIndex,\n      ...rest\n    }: Omit<DescendantType, \"index\"> & { index?: number | undefined }) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => {\n        let newItems: DescendantType[];\n        if (explicitIndex != null) {\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: explicitIndex,\n            } as DescendantType,\n          ];\n        } else if (items.length === 0) {\n          // If there are no items, register at index 0 and bail.\n          newItems = [\n            ...items,\n            {\n              ...rest,\n              element,\n              index: 0,\n            } as DescendantType,\n          ];\n        } else if (items.find((item) => item.element === element)) {\n          // If the element is already registered, just use the same array\n          newItems = items;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n          let index = items.findIndex((item) => {\n            if (!item.element || !element) {\n              return false;\n            }\n            // Does this element's DOM node appear before another item in the\n            // array in our DOM tree? If so, return true to grab the index at\n            // this point in the array so we know where to insert the new\n            // element.\n            return Boolean(\n              item.element.compareDocumentPosition(element as Node) &\n                Node.DOCUMENT_POSITION_PRECEDING\n            );\n          });\n\n          let newItem = {\n            ...rest,\n            element,\n            index,\n          } as DescendantType;\n\n          // If an index is not found we will push the element to the end.\n          if (index === -1) {\n            newItems = [...items, newItem];\n          } else {\n            newItems = [\n              ...items.slice(0, index),\n              newItem,\n              ...items.slice(index),\n            ];\n          }\n        }\n        return newItems.map((item, index) => ({ ...item, index }));\n      });\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  let unregisterDescendant = useCallback(\n    (element: DescendantType[\"element\"]) => {\n      if (!element) {\n        return;\n      }\n\n      set((items) => items.filter((item) => element !== item.element));\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  return (\n    <Ctx.Provider\n      value={useMemo(() => {\n        return {\n          descendants: items,\n          registerDescendant,\n          unregisterDescendant,\n        };\n      }, [items, registerDescendant, unregisterDescendant])}\n    >\n      {children}\n    </Ctx.Provider>\n  );\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nexport function useDescendantKeyDown<\n  DescendantType extends Descendant,\n  K extends keyof DescendantType = keyof DescendantType\n>(\n  context: React.Context<DescendantContextValue<DescendantType>>,\n  options: {\n    currentIndex: number | null | undefined;\n    key?: K | \"option\";\n    filter?: (descendant: DescendantType) => boolean;\n    orientation?: \"vertical\" | \"horizontal\" | \"both\";\n    rotate?: boolean;\n    rtl?: boolean;\n    callback(nextOption: DescendantType | DescendantType[K]): void;\n  }\n) {\n  let { descendants } = useContext(context);\n  let {\n    callback,\n    currentIndex,\n    filter,\n    key = \"index\" as K,\n    orientation = \"vertical\",\n    rotate = true,\n    rtl = false,\n  } = options;\n  let index = currentIndex ?? -1;\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    if (\n      ![\n        \"ArrowDown\",\n        \"ArrowUp\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"PageUp\",\n        \"PageDown\",\n        \"Home\",\n        \"End\",\n      ].includes(event.key)\n    ) {\n      return;\n    }\n\n    // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n    let selectableDescendants = filter\n      ? descendants.filter(filter)\n      : descendants;\n\n    // Current index should map to the updated array vs. the original\n    // descendants array.\n    if (filter) {\n      index = selectableDescendants.findIndex(\n        (descendant) => descendant.index === currentIndex\n      );\n    }\n\n    // We need some options for any of this to work!\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      let atBottom = index === selectableDescendants.length - 1;\n      return atBottom\n        ? rotate\n          ? getFirstOption()\n          : selectableDescendants[index]\n        : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      return atTop\n        ? rotate\n          ? getLastOption()\n          : selectableDescendants[index]\n        : selectableDescendants[\n            (index - 1 + selectableDescendants.length) %\n              selectableDescendants.length\n          ];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n        break;\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          let prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n        break;\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n        break;\n      case \"PageUp\":\n        event.preventDefault();\n        let prevOrFirst = (event.ctrlKey\n          ? getPreviousOption\n          : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n      case \"Home\":\n        event.preventDefault();\n        let first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n      case \"PageDown\":\n        event.preventDefault();\n        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n      case \"End\":\n        event.preventDefault();\n        let last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeElement<T> = T extends Element ? T : HTMLElement;\n\nexport type Descendant<ElementType = HTMLElement> = {\n  element: SomeElement<ElementType> | null;\n  index: number;\n};\n\nexport interface DescendantContextValue<DescendantType extends Descendant> {\n  descendants: DescendantType[];\n  registerDescendant(descendant: DescendantType): void;\n  unregisterDescendant(element: DescendantType[\"element\"]): void;\n}\n", "/*\n * Welcome to @reach/auto-id!\n\n * Let's see if we can make sense of why this hook exists and its\n * implementation.\n *\n * Some background:\n *   1. Accessibiliy APIs rely heavily on element IDs\n *   2. Requiring developers to put IDs on every element in Reach UI is both\n *      cumbersome and error-prone\n *   3. With a component model, we can generate IDs for them!\n *\n * Solution 1: Generate random IDs.\n *\n * This works great as long as you don't server render your app. When React (in\n * the client) tries to reuse the markup from the server, the IDs won't match\n * and React will then recreate the entire DOM tree.\n *\n * Solution 2: Increment an integer\n *\n * This sounds great. Since we're rendering the exact same tree on the server\n * and client, we can increment a counter and get a deterministic result between\n * client and server. Also, JS integers can go up to nine-quadrillion. I'm\n * pretty sure the tab will be closed before an app never needs\n * 10 quadrillion IDs!\n *\n * Problem solved, right?\n *\n * Ah, but there's a catch! React's concurrent rendering makes this approach\n * non-deterministic. While the client and server will end up with the same\n * elements in the end, depending on suspense boundaries (and possibly some user\n * input during the initial render) the incrementing integers won't always match\n * up.\n *\n * Solution 3: Don't use IDs at all on the server; patch after first render.\n *\n * What we've done here is solution 2 with some tricks. With this approach, the\n * ID returned is an empty string on the first render. This way the server and\n * client have the same markup no matter how wild the concurrent rendering may\n * have gotten.\n *\n * After the render, we patch up the components with an incremented ID. This\n * causes a double render on any components with `useId`. Shouldn't be a problem\n * since the components using this hook should be small, and we're only updating\n * the ID attribute on the DOM, nothing big is happening.\n *\n * It doesn't have to be an incremented number, though--we could do generate\n * random strings instead, but incrementing a number is probably the cheapest\n * thing we can do.\n *\n * Additionally, we only do this patchup on the very first client render ever.\n * Any calls to `useId` that happen dynamically in the client will be\n * populated immediately with a value. So, we only get the double render after\n * server hydration and never again, SO BACK OFF ALRIGHT?\n */\n\nimport { useState, useEffect } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"@reach/utils\";\n\nlet serverHandoffComplete = false;\nlet id = 0;\nconst genId = () => ++id;\n\n/**\n * useId\n *\n * Autogenerate IDs to facilitate WAI-ARIA and server rendering.\n *\n * Note: The returned ID will initially be `null` and will update after a\n * component mounts. Users may need to supply their own ID if they need\n * consistent values for SSR.\n *\n * @see Docs https://reacttraining.com/reach-ui/auto-id\n */\nexport const useId = (idFromProps?: string | null) => {\n  /*\n   * If this instance isn't part of the initial render, we don't have to do the\n   * double render/patch-up dance. We can just generate the ID and return it.\n   */\n  const initialId = idFromProps || (serverHandoffComplete ? genId() : null);\n\n  const [id, setId] = useState(initialId);\n\n  useIsomorphicLayoutEffect(() => {\n    if (id === null) {\n      /*\n       * Patch the ID after render. We do this in `useLayoutEffect` to avoid any\n       * rendering flicker, though it'll make the first render slower (unlikely\n       * to matter, but you're welcome to measure your app and let us know if\n       * it's a problem).\n       */\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (serverHandoffComplete === false) {\n      /*\n       * Flag all future uses of `useId` to skip the update dance. This is in\n       * `useEffect` because it goes after `useLayoutEffect`, ensuring we don't\n       * accidentally bail out of the patch-up dance prematurely.\n       */\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id != null ? String(id) : undefined;\n};\n", "/**\n * Welcome to @reach/tabs!\n *\n * An accessible tabs component.\n *\n * The `Tab` and `TabPanel` elements are associated by their order in the tree.\n * None of the components are empty wrappers, each is associated with a real DOM\n * element in the document, giving you maximum control over styling and composition.\n *\n * You can render any other elements you want inside of `Tabs`, but `TabList`\n * should only render `Tab` elements, and `TabPanels` should only render\n * `TabPanel` elements.\n *\n * @see Docs     https://reacttraining.com/reach-ui/tabs\n * @see Source   https://github.com/reach/reach-ui/tree/main/packages/tabs\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n */\n\nimport React, {\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  Children,\n} from \"react\";\nimport PropTypes from \"prop-types\";\nimport {\n  createDescendantContext,\n  Descendant,\n  DescendantProvider,\n  useDescendant,\n  useDescendantKeyDown,\n  useDescendantsInit,\n  useDescendants,\n} from \"@reach/descendants\";\nimport {\n  boolOrBoolString,\n  checkStyles,\n  cloneValidElement,\n  createNamedContext,\n  forwardRefWithAs,\n  getElementComputedStyle,\n  isNumber,\n  isFunction,\n  makeId,\n  memoWithAs,\n  noop,\n  useControlledSwitchWarning,\n  useControlledState,\n  useEventCallback,\n  useForkedRef,\n  useIsomorphicLayoutEffect,\n  useUpdateEffect,\n  wrapEvent,\n} from \"@reach/utils\";\nimport { useId } from \"@reach/auto-id\";\n\nconst TabsDescendantsContext = createDescendantContext<TabDescendant>(\n  \"TabsDescendantsContext\"\n);\n\nconst TabPanelDescendantsContext = createDescendantContext<TabPanelDescendant>(\n  \"TabPanelDescendantsContext\"\n);\nconst TabsContext = createNamedContext(\n  \"TabsContext\",\n  {} as InternalTabsContextValue\n);\n\nexport enum TabsKeyboardActivation {\n  Auto = \"auto\",\n  Manual = \"manual\",\n}\n\nexport enum TabsOrientation {\n  Horizontal = \"horizontal\",\n  Vertical = \"vertical\",\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Tabs\n *\n * The parent component of the tab interface.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabs\n */\nexport const Tabs = forwardRefWithAs<TabsProps, \"div\">(function Tabs(\n  {\n    as: Comp = \"div\",\n    children,\n    defaultIndex,\n    orientation = TabsOrientation.Horizontal,\n    index: controlledIndex = undefined,\n    keyboardActivation = TabsKeyboardActivation.Auto,\n    onChange,\n    readOnly = false,\n    ...props\n  },\n  ref\n) {\n  let isControlled = useRef(controlledIndex != null);\n  useControlledSwitchWarning(controlledIndex, \"index\", \"Tabs\");\n\n  let _id = useId(props.id);\n  let id = props.id ?? makeId(\"tabs\", _id);\n\n  // We only manage focus if the user caused the update vs. a new controlled\n  // index coming in.\n  let userInteractedRef = useRef(false);\n\n  let selectedPanelRef = useRef<HTMLElement | null>(null);\n\n  let isRTL = useRef(false);\n\n  let [selectedIndex, setSelectedIndex] = useControlledState(\n    controlledIndex,\n    defaultIndex ?? 0\n  );\n\n  let [focusedIndex, setFocusedIndex] = useState(-1);\n\n  let [tabs, setTabs] = useDescendantsInit<TabDescendant>();\n\n  let context: InternalTabsContextValue = useMemo(() => {\n    return {\n      focusedIndex,\n      id,\n      isControlled: isControlled.current,\n      isRTL,\n      keyboardActivation,\n      onFocusPanel() {\n        selectedPanelRef.current?.focus();\n      },\n      onSelectTab: readOnly\n        ? noop\n        : (index: number) => {\n            userInteractedRef.current = true;\n            onChange && onChange(index);\n            setSelectedIndex(index);\n          },\n      onSelectTabWithKeyboard: readOnly\n        ? noop\n        : (index: number) => {\n            userInteractedRef.current = true;\n            switch (keyboardActivation) {\n              case TabsKeyboardActivation.Manual:\n                tabs[index].element?.focus();\n                return;\n              case TabsKeyboardActivation.Auto:\n              default:\n                onChange && onChange(index);\n                setSelectedIndex(index);\n                return;\n            }\n          },\n      orientation,\n      selectedIndex,\n      selectedPanelRef,\n      setFocusedIndex,\n      setSelectedIndex,\n      userInteractedRef,\n    };\n  }, [\n    focusedIndex,\n    id,\n    keyboardActivation,\n    onChange,\n    orientation,\n    readOnly,\n    selectedIndex,\n    setSelectedIndex,\n    tabs,\n  ]);\n\n  useEffect(() => checkStyles(\"tabs\"), []);\n\n  return (\n    <DescendantProvider\n      context={TabsDescendantsContext}\n      items={tabs}\n      set={setTabs}\n    >\n      <TabsContext.Provider value={context}>\n        <Comp\n          {...props}\n          ref={ref}\n          data-reach-tabs=\"\"\n          data-orientation={orientation}\n          id={props.id}\n        >\n          {isFunction(children)\n            ? children({ focusedIndex, id, selectedIndex })\n            : children}\n        </Comp>\n      </TabsContext.Provider>\n    </DescendantProvider>\n  );\n});\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-props\n */\nexport type TabsProps = {\n  /**\n   * Tabs expects `<TabList>` and `<TabPanels>` as children. The order doesn't\n   * matter, you can have tabs on the top or the bottom. In fact, you could have\n   * tabs on both the bottom and the top at the same time. You can have random\n   * elements inside as well.\n   *\n   * You can also pass a render function to access data relevant to nested\n   * components.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-children\n   */\n  children: React.ReactNode | ((props: TabsContextValue) => React.ReactNode);\n  /**\n   * Like form inputs, a tab's state can be controlled by the owner. Make sure\n   * to include an `onChange` as well, or else the tabs will not be interactive.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-index\n   */\n  index?: number;\n  /**\n   * Describes the activation mode when navigating a tablist with a keyboard.\n   * When set to `\"auto\"`, a tab panel is activated automatically when a tab is\n   * highlighted using arrow keys. When set to `\"manual\"`, the user must\n   * activate the tab panel with either the `Spacebar` or `Enter` keys. Defaults\n   * to `\"auto\"`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-keyboardactivation\n   */\n  keyboardActivation?: TabsKeyboardActivation;\n  /**\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-readonly\n   */\n  readOnly?: boolean;\n  /**\n   * Starts the tabs at a specific index.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-defaultindex\n   */\n  defaultIndex?: number;\n  /**\n   * Allows you to switch the orientation of the tabs relative to their tab\n   * panels. This value can either be `\"horizontal\"`\n   * (`TabsOrientation.Horizontal`) or `\"vertical\"`\n   * (`TabsOrientation.Vertical`). Defaults to `\"horizontal\"`.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-orientation\n   * @see MDN  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties\n   */\n  orientation?: TabsOrientation;\n  /**\n   * Calls back with the tab index whenever the user changes tabs, allowing your\n   * app to synchronize with it.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabs-onchange\n   */\n  onChange?: (index: number) => void;\n};\n\nif (__DEV__) {\n  Tabs.displayName = \"Tabs\";\n  Tabs.propTypes = {\n    children: PropTypes.node.isRequired,\n    onChange: PropTypes.func,\n    orientation: PropTypes.oneOf(Object.values(TabsOrientation)),\n    index: (props, name, compName, location, propName) => {\n      let val = props[name];\n      if (\n        props.index > -1 &&\n        props.onChange == null &&\n        props.readOnly !== true\n      ) {\n        return new Error(\n          \"You provided a value prop to `\" +\n            compName +\n            \"` without an `onChange` handler. This will render a read-only tabs element. If the tabs should be mutable use `defaultIndex`. Otherwise, set `onChange`.\"\n        );\n      } else if (val != null && !isNumber(val)) {\n        return new Error(\n          `Invalid prop \\`${propName}\\` supplied to \\`${compName}\\`. Expected \\`number\\`, received \\`${\n            Array.isArray(val) ? \"array\" : typeof val\n          }\\`.`\n        );\n      }\n      return null;\n    },\n    defaultIndex: PropTypes.number,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * TabList\n *\n * The parent component of the tabs.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tablist\n */\nconst TabListImpl = forwardRefWithAs<TabListProps, \"div\">(function TabList(\n  { children, as: Comp = \"div\", onKeyDown, ...props },\n  forwardedRef\n) {\n  const {\n    focusedIndex,\n    isControlled,\n    isRTL,\n    keyboardActivation,\n    onSelectTabWithKeyboard,\n    orientation,\n    selectedIndex,\n    setSelectedIndex,\n  } = useContext(TabsContext);\n  let tabs = useDescendants(TabsDescendantsContext);\n\n  let ownRef = useRef<HTMLElement | null>(null);\n  let ref = useForkedRef(forwardedRef, ownRef);\n\n  useEffect(() => {\n    if (\n      ownRef.current &&\n      ((ownRef.current.ownerDocument &&\n        ownRef.current.ownerDocument.dir === \"rtl\") ||\n        getElementComputedStyle(ownRef.current, \"direction\") === \"rtl\")\n    ) {\n      isRTL.current = true;\n    }\n  }, [isRTL]);\n\n  let handleKeyDown = useEventCallback(\n    wrapEvent(\n      onKeyDown,\n      useDescendantKeyDown(TabsDescendantsContext, {\n        currentIndex:\n          keyboardActivation === TabsKeyboardActivation.Manual\n            ? focusedIndex\n            : selectedIndex,\n        orientation,\n        rotate: true,\n        callback: onSelectTabWithKeyboard,\n        filter: (tab) => !tab.disabled,\n        rtl: isRTL.current,\n      })\n    )\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    // In the event an uncontrolled component's selected index is disabled,\n    // (this should only happen if the first tab is disabled and no default\n    // index is set), we need to override the selection to the next selectable\n    // index value.\n    if (!isControlled && boolOrBoolString(tabs[selectedIndex]?.disabled)) {\n      let next = tabs.find((tab) => !tab.disabled);\n      if (next) {\n        setSelectedIndex(next.index);\n      }\n    }\n  }, [tabs, isControlled, selectedIndex, setSelectedIndex]);\n\n  return (\n    <Comp\n      // The element that serves as the container for the set of tabs has role\n      // `tablist`\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      role=\"tablist\"\n      // If the `tablist` element is vertically oriented, it has the property\n      // `aria-orientation` set to `\"vertical\"`. The default value of\n      // `aria-orientation` for a tablist element is `\"horizontal\"`.\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      aria-orientation={orientation}\n      {...props}\n      data-reach-tab-list=\"\"\n      ref={ref}\n      onKeyDown={handleKeyDown}\n    >\n      {Children.map(children, (child, index) => {\n        // TODO: Remove in 1.0\n        return cloneValidElement(child, {\n          isSelected: index === selectedIndex,\n        });\n      })}\n    </Comp>\n  );\n});\n\nif (__DEV__) {\n  TabListImpl.displayName = \"TabList\";\n  TabListImpl.propTypes = {\n    as: PropTypes.any,\n    children: PropTypes.node,\n  };\n}\n\nconst TabList = memoWithAs(TabListImpl);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tablist-props\n */\nexport type TabListProps = {\n  /**\n   * `TabList` expects multiple `Tab` elements as children.\n   *\n   * `TabPanels` expects multiple `TabPanel` elements as children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tablist-children\n   */\n  children?: React.ReactNode;\n};\n\nif (__DEV__) {\n  TabList.displayName = \"TabList\";\n}\n\nexport { TabList };\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Tab\n *\n * The interactive element that changes the selected panel.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tab\n */\nexport const Tab = forwardRefWithAs<\n  // TODO: Remove this when cloneElement is removed\n  TabProps & { isSelected?: boolean },\n  \"button\"\n>(function Tab(\n  {\n    children,\n    isSelected: _,\n    as: Comp = \"button\",\n    index: indexProp,\n    disabled,\n    onBlur,\n    onFocus,\n    ...props\n  },\n  forwardedRef\n) {\n  const {\n    id: tabsId,\n    onSelectTab,\n    orientation,\n    selectedIndex,\n    userInteractedRef,\n    setFocusedIndex,\n  } = useContext(TabsContext);\n  const ownRef = useRef<HTMLElement | null>(null);\n  const ref = useForkedRef(forwardedRef, ownRef);\n  const index = useDescendant(\n    {\n      element: ownRef.current!,\n      disabled: !!disabled,\n    },\n    TabsDescendantsContext,\n    indexProp\n  );\n  const htmlType =\n    Comp === \"button\" && props.type == null ? \"button\" : props.type;\n\n  const isSelected = index === selectedIndex;\n\n  function onSelect() {\n    onSelectTab(index);\n  }\n\n  useUpdateEffect(() => {\n    if (isSelected && ownRef.current && userInteractedRef.current) {\n      userInteractedRef.current = false;\n      ownRef.current.focus();\n    }\n  }, [isSelected, userInteractedRef]);\n\n  let handleFocus = useEventCallback(\n    wrapEvent(onFocus, () => {\n      setFocusedIndex(index);\n    })\n  );\n\n  let handleBlur = useEventCallback(\n    wrapEvent(onFocus, () => {\n      setFocusedIndex(-1);\n    })\n  );\n\n  return (\n    <Comp\n      // Each element with role `tab` has the property `aria-controls` referring\n      // to its associated `tabpanel` element.\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      aria-controls={makeId(tabsId, \"panel\", index)}\n      aria-disabled={disabled}\n      // The active tab element has the state `aria-selected` set to `true` and\n      // all other tab elements have it set to `false`.\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      aria-selected={isSelected}\n      // Each element that serves as a tab has role `tab` and is contained\n      // within the element with role `tablist`.\n      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n      role=\"tab\"\n      tabIndex={isSelected ? 0 : -1}\n      {...props}\n      ref={ref}\n      data-reach-tab=\"\"\n      data-orientation={orientation}\n      data-selected={isSelected ? \"\" : undefined}\n      disabled={disabled}\n      id={makeId(tabsId, \"tab\", index)}\n      onClick={onSelect}\n      onFocus={handleFocus}\n      onBlur={handleBlur}\n      type={htmlType}\n    >\n      {children}\n    </Comp>\n  );\n});\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tab-props\n */\nexport type TabProps = {\n  /**\n   * `Tab` can receive any type of children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tab-children\n   */\n  children?: React.ReactNode;\n  /**\n   * Disables a tab when true. Clicking will not work and keyboard navigation\n   * will skip over it.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tab-disabled\n   */\n  disabled?: boolean;\n  index?: number;\n};\n\nif (__DEV__) {\n  Tab.displayName = \"Tab\";\n  Tab.propTypes = {\n    children: PropTypes.node,\n    disabled: PropTypes.bool,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * TabPanels\n *\n * The parent component of the panels.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanels\n */\nconst TabPanelsImpl = forwardRefWithAs<TabPanelsProps, \"div\">(\n  function TabPanels({ children, as: Comp = \"div\", ...props }, forwardedRef) {\n    let ownRef = useRef();\n    let ref = useForkedRef(ownRef, forwardedRef);\n    let [tabPanels, setTabPanels] = useDescendantsInit<TabPanelDescendant>();\n\n    return (\n      <DescendantProvider\n        context={TabPanelDescendantsContext}\n        items={tabPanels}\n        set={setTabPanels}\n      >\n        <Comp {...props} ref={ref} data-reach-tab-panels=\"\">\n          {children}\n        </Comp>\n      </DescendantProvider>\n    );\n  }\n);\n\nif (__DEV__) {\n  TabPanelsImpl.displayName = \"TabPanels\";\n  TabPanelsImpl.propTypes = {\n    as: PropTypes.any,\n    children: PropTypes.node,\n  };\n}\n\nconst TabPanels = memoWithAs(TabPanelsImpl);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanels-props\n */\nexport type TabPanelsProps = TabListProps & {};\n\nif (__DEV__) {\n  TabPanels.displayName = \"TabPanels\";\n}\n\nexport { TabPanels };\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * TabPanel\n *\n * The panel that displays when it's corresponding tab is active.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanel\n */\nexport const TabPanel = forwardRefWithAs<TabPanelProps, \"div\">(\n  function TabPanel(\n    { children, \"aria-label\": ariaLabel, as: Comp = \"div\", ...props },\n    forwardedRef\n  ) {\n    let { selectedPanelRef, selectedIndex, id: tabsId } = useContext(\n      TabsContext\n    );\n    let ownRef = useRef<HTMLElement | null>(null);\n\n    let index = useDescendant(\n      { element: ownRef.current! },\n      TabPanelDescendantsContext\n    );\n\n    let id = makeId(tabsId, \"panel\", index);\n\n    // Because useDescendant will always return -1 on the first render,\n    // `isSelected` will briefly be false for all tabs. We set a tab panel's\n    // hidden attribute based `isSelected` being false, meaning that all tabs\n    // are initially hidden. This makes it impossible for consumers to do\n    // certain things, like focus an element inside the active tab panel when\n    // the page loads. So what we can do is track that a panel is \"ready\" to be\n    // hidden once effects are run (descendants work their magic in\n    // useLayoutEffect, so we can set our ref in useEffecct to run later). We\n    // can use a ref instead of state because we're always geting a re-render\n    // anyway thanks to descendants. This is a little more coupled to the\n    // implementation details of descendants than I'd like, but we'll add a test\n    // to (hopefully) catch any regressions.\n    let isSelected = index === selectedIndex;\n    let readyToHide = useRef(false);\n    let hidden = readyToHide.current ? !isSelected : false;\n    React.useEffect(() => {\n      readyToHide.current = true;\n    }, []);\n\n    let ref = useForkedRef(\n      forwardedRef,\n      ownRef,\n      isSelected ? selectedPanelRef : null\n    );\n\n    return (\n      <Comp\n        // Each element with role `tabpanel` has the property `aria-labelledby`\n        // referring to its associated tab element.\n        aria-labelledby={makeId(tabsId, \"tab\", index)}\n        hidden={hidden}\n        // Each element that contains the content panel for a tab has role\n        // `tabpanel`.\n        // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel\n        role=\"tabpanel\"\n        tabIndex={isSelected ? 0 : -1}\n        {...props}\n        ref={ref}\n        data-reach-tab-panel=\"\"\n        id={id}\n      >\n        {children}\n      </Comp>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanel-props\n */\nexport type TabPanelProps = {\n  /**\n   * `TabPanel` can receive any type of children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/tabs#tabpanel-children\n   */\n  children?: React.ReactNode;\n};\n\nif (__DEV__) {\n  TabPanel.displayName = \"TabPanel\";\n  TabPanel.propTypes = {\n    as: PropTypes.any,\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hook that exposes data for a given `Tabs` component to its descendants.\n *\n * @see Docs https://reacttraining.com/reach-ui/tabs#usetabscontext\n */\nexport function useTabsContext(): TabsContextValue {\n  let { focusedIndex, id, selectedIndex } = useContext(TabsContext);\n  return useMemo(\n    () => ({\n      focusedIndex,\n      id,\n      selectedIndex,\n    }),\n    [focusedIndex, id, selectedIndex]\n  );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype TabDescendant = Descendant<HTMLElement> & {\n  disabled: boolean;\n};\n\ntype TabPanelDescendant = Descendant<HTMLElement>;\n\nexport type TabsContextValue = {\n  focusedIndex: number;\n  id: string;\n  selectedIndex: number;\n};\n\ntype InternalTabsContextValue = {\n  focusedIndex: number;\n  id: string;\n  isControlled: boolean;\n  isRTL: React.MutableRefObject<boolean>;\n  keyboardActivation: TabsKeyboardActivation;\n  onFocusPanel: () => void;\n  onSelectTab: (index: number) => void;\n  onSelectTabWithKeyboard: (index: number) => void;\n  orientation: TabsOrientation;\n  selectedIndex: number;\n  selectedPanelRef: React.MutableRefObject<HTMLElement | null>;\n  setFocusedIndex: React.Dispatch<React.SetStateAction<number>>;\n  setSelectedIndex: React.Dispatch<React.SetStateAction<number>>;\n  userInteractedRef: React.MutableRefObject<boolean>;\n};\n"],
  "mappings": "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",
  "names": ["printWarning", "useIsomorphicLayoutEffect", "canUseDOM", "React", "useLayoutEffect", "useEffect", "checkedPkgs", "checkStyles", "noop", "process", "env", "NODE_ENV", "packageName", "parseInt", "window", "getComputedStyle", "document", "body", "getPropertyValue", "console", "warn", "ponyfillGlobal", "Math", "self", "Function", "assignRef", "ref", "value", "isFunction", "current", "error", "Error", "boolOrBoolString", "isBoolean", "createElement", "cloneValidElement", "element", "props", "children", "isValidElement", "cloneElement", "createNamedContext", "name", "defaultValue", "Ctx", "createContext", "displayName", "forwardRefWithAs", "render", "forwardRef", "memoWithAs", "Component", "propsAreEqual", "memo", "getElementComputedStyle", "element", "styleProp", "y", "doc", "getOwnerDocument", "currentStyle", "defaultView", "isFunction", "getComputedStyle", "getPropertyValue", "ownerDocument", "canUseDOM", "document", "isBoolean", "value", "isFunction", "toString", "call", "isNumber", "makeId", "args", "filter", "val", "join", "noop", "useControlledState", "controlledValue", "defaultValue", "controlledRef", "useRef", "useState", "valueState", "setValue", "set", "useCallback", "n", "current", "useControlledSwitchWarning", "noop", "controlledPropName", "componentName", "nameCache", "useEffect", "wasControlled", "isControlled", "console", "error", "useCheckStyles", "pkg", "name", "checkStyles", "useEventCallback", "callback", "ref", "useRef", "useIsomorphicLayoutEffect", "current", "useCallback", "event", "args", "useForkedRef", "refs", "useMemo", "every", "ref", "node", "forEach", "assignRef", "usePrevious", "value", "useRef", "useEffect", "current", "useUpdateEffect", "effect", "deps", "mounted", "useStateLogger", "noop", "state", "DEBUG", "debugRef", "console", "group", "log", "groupEnd", "wrapEvent", "theirHandler", "ourHandler", "event", "defaultPrevented", "createDescendantContext", "name", "initialValue", "descendants", "createNamedContext", "registerDescendant", "noop", "unregisterDescendant", "useDescendant", "descendant", "context", "indexProp", "useState", "forceUpdate", "useContext", "index", "findIndex", "item", "element", "previousDescendants", "usePrevious", "someDescendantsHaveChanged", "some", "useIsomorphicLayoutEffect", "Object", "values", "useDescendantsInit", "useDescendants", "ctx", "DescendantProvider", "Ctx", "children", "items", "set", "useCallback", "explicitIndex", "rest", "newItems", "length", "find", "Boolean", "compareDocumentPosition", "Node", "DOCUMENT_POSITION_PRECEDING", "newItem", "slice", "map", "filter", "React", "Provider", "value", "useMemo", "useDescendantKeyDown", "options", "callback", "currentIndex", "key", "orientation", "rotate", "rtl", "handleKeyDown", "event", "includes", "selectableDescendants", "getNextOption", "atBottom", "getFirstOption", "getPreviousOption", "atTop", "getLastOption", "preventDefault", "next", "prev", "nextOrPrev", "prevOrNext", "prevOrFirst", "ctrlKey", "first", "nextOrLast", "last", "serverHandoffComplete", "id", "genId", "useId", "idFromProps", "initialId", "useState", "setId", "useIsomorphicLayoutEffect", "useEffect", "String", "undefined", "TabsDescendantsContext", "createDescendantContext", "TabPanelDescendantsContext", "TabsContext", "createNamedContext", "TabsKeyboardActivation", "TabsOrientation", "Tabs", "forwardRefWithAs", "ref", "as", "Comp", "children", "defaultIndex", "orientation", "Horizontal", "index", "controlledIndex", "undefined", "keyboardActivation", "Auto", "onChange", "readOnly", "props", "isControlled", "useRef", "useControlledSwitchWarning", "_id", "useId", "id", "makeId", "userInteractedRef", "selectedPanelRef", "isRTL", "useControlledState", "selectedIndex", "setSelectedIndex", "useState", "focusedIndex", "setFocusedIndex", "useDescendantsInit", "tabs", "setTabs", "context", "useMemo", "current", "onFocusPanel", "focus", "onSelectTab", "noop", "onSelectTabWithKeyboard", "Manual", "element", "useEffect", "checkStyles", "React", "DescendantProvider", "items", "set", "Provider", "value", "isFunction", "displayName", "propTypes", "PropTypes", "node", "isRequired", "func", "oneOf", "Object", "values", "name", "compName", "location", "propName", "val", "Error", "isNumber", "Array", "isArray", "number", "TabListImpl", "TabList", "forwardedRef", "onKeyDown", "useContext", "useDescendants", "ownRef", "useForkedRef", "ownerDocument", "dir", "getElementComputedStyle", "handleKeyDown", "useEventCallback", "wrapEvent", "useDescendantKeyDown", "currentIndex", "rotate", "callback", "filter", "tab", "disabled", "rtl", "useIsomorphicLayoutEffect", "boolOrBoolString", "next", "find", "role", "Children", "map", "child", "cloneValidElement", "isSelected", "any", "memoWithAs", "Tab", "_", "indexProp", "onBlur", "onFocus", "tabsId", "useDescendant", "htmlType", "type", "onSelect", "useUpdateEffect", "handleFocus", "handleBlur", "tabIndex", "onClick", "bool", "TabPanelsImpl", "TabPanels", "tabPanels", "setTabPanels", "TabPanel", "ariaLabel", "readyToHide", "hidden", "useTabsContext"]
}
