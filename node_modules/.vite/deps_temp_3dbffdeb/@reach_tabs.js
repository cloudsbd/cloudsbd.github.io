import {
  require_prop_types
} from "./chunk-GR575YFT.js";
import "./chunk-M7AQCQI4.js";
import {
  require_react
} from "./chunk-M56NR37J.js";
import {
  __commonJS,
  __toESM
} from "./chunk-WGAPYIUP.js";

// ../../node_modules/warning/warning.js
var require_warning = __commonJS({
  "../../node_modules/warning/warning.js"(exports, module) {
    "use strict";
    var __DEV__ = true;
    var warning = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
      warning = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      };
    }
    var printWarning;
    module.exports = warning;
  }
});

// ../../node_modules/@reach/tabs/dist/tabs.esm.js
var import_react4 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// ../../node_modules/@reach/descendants/dist/descendants.esm.js
var import_react2 = __toESM(require_react());

// ../../node_modules/@reach/utils/dist/utils.esm.js
var import_react = __toESM(require_react());
var import_warning = __toESM(require_warning());
var useIsomorphicLayoutEffect = canUseDOM() ? import_react.default.useLayoutEffect : import_react.default.useEffect;
var checkedPkgs = {};
var checkStyles = noop;
if (true) {
  _ref = typeof process !== "undefined" ? process : {
    env: {
      NODE_ENV: "development"
    }
  }, env = _ref.env;
  checkStyles = function checkStyles2(packageName) {
    if (checkedPkgs[packageName])
      return;
    checkedPkgs[packageName] = true;
    if (env.NODE_ENV !== "test" && parseInt(window.getComputedStyle(document.body).getPropertyValue("--reach-" + packageName), 10) !== 1) {
      console.warn("@reach/" + packageName + ' styles not found. If you are using a bundler like webpack or parcel include this in the entry file of your app before any of your own styles:\n\n    import "@reach/' + packageName + `/styles.css";

  Otherwise you'll need to include them some other way:

    <link rel="stylesheet" type="text/css" href="node_modules/@reach/` + packageName + '/styles.css" />\n\n  For more information visit https://ui.reach.tech/styling.\n  ');
    }
  };
}
var _ref;
var env;
var ponyfillGlobal = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : (
  // eslint-disable-next-line no-new-func
  Function("return this")()
);
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (isFunction(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error('Cannot assign value "' + value + '" to ref "' + ref + '"');
    }
  }
}
function boolOrBoolString(value) {
  return value === "true" ? true : isBoolean(value) ? value : false;
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function cloneValidElement(element, props) {
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }
  return (0, import_react.isValidElement)(element) ? import_react.cloneElement.apply(void 0, [element, props].concat(children)) : element;
}
function createNamedContext(name, defaultValue) {
  var Ctx = (0, import_react.createContext)(defaultValue);
  Ctx.displayName = name;
  return Ctx;
}
function forwardRefWithAs(render) {
  return import_react.default.forwardRef(render);
}
function memoWithAs(Component, propsAreEqual) {
  return import_react.default.memo(Component, propsAreEqual);
}
function getElementComputedStyle(element, styleProp) {
  var y = null;
  var doc = getOwnerDocument(element);
  if (element.currentStyle) {
    y = element.currentStyle[styleProp];
  } else if (doc && doc.defaultView && isFunction(doc.defaultView.getComputedStyle)) {
    y = doc.defaultView.getComputedStyle(element, null).getPropertyValue(styleProp);
  }
  return y;
}
function getOwnerDocument(element) {
  return element && element.ownerDocument ? element.ownerDocument : canUseDOM() ? document : null;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
function isNumber(value) {
  return typeof value === "number";
}
function makeId() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  return args.filter(function(val) {
    return val != null;
  }).join("--");
}
function noop() {
}
function useControlledState(controlledValue, defaultValue) {
  var controlledRef = (0, import_react.useRef)(controlledValue != null);
  var _useState = (0, import_react.useState)(defaultValue), valueState = _useState[0], setValue = _useState[1];
  var set = (0, import_react.useCallback)(function(n) {
    if (!controlledRef.current) {
      setValue(n);
    }
  }, []);
  return [controlledRef.current ? controlledValue : valueState, set];
}
var useControlledSwitchWarning = noop;
if (true) {
  useControlledSwitchWarning = function useControlledSwitchWarning2(controlledValue, controlledPropName, componentName) {
    var controlledRef = (0, import_react.useRef)(controlledValue != null);
    var nameCache = (0, import_react.useRef)({
      componentName,
      controlledPropName
    });
    (0, import_react.useEffect)(function() {
      nameCache.current = {
        componentName,
        controlledPropName
      };
    }, [componentName, controlledPropName]);
    (0, import_react.useEffect)(function() {
      var wasControlled = controlledRef.current;
      var _nameCache$current = nameCache.current, componentName2 = _nameCache$current.componentName, controlledPropName2 = _nameCache$current.controlledPropName;
      var isControlled = controlledValue != null;
      if (wasControlled !== isControlled) {
        console.error("A component is changing an " + (wasControlled ? "" : "un") + "controlled `" + controlledPropName2 + "` state of " + componentName2 + " to be " + (wasControlled ? "un" : "") + "controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled " + componentName2 + " element for the lifetime of the component.\nMore info: https://fb.me/react-controlled-components");
      }
    }, [controlledValue]);
  };
}
var useCheckStyles = noop;
if (true) {
  useCheckStyles = function useCheckStyles2(pkg) {
    var name = (0, import_react.useRef)(pkg);
    (0, import_react.useEffect)(function() {
      return void (name.current = pkg);
    }, [pkg]);
    (0, import_react.useEffect)(function() {
      return checkStyles(name.current);
    }, []);
  };
}
function useEventCallback(callback) {
  var ref = (0, import_react.useRef)(callback);
  useIsomorphicLayoutEffect(function() {
    ref.current = callback;
  });
  return (0, import_react.useCallback)(function(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return ref.current.apply(ref, [event].concat(args));
  }, []);
}
function useForkedRef() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return (0, import_react.useMemo)(function() {
    if (refs.every(function(ref) {
      return ref == null;
    })) {
      return null;
    }
    return function(node) {
      refs.forEach(function(ref) {
        assignRef(ref, node);
      });
    };
  }, [].concat(refs));
}
function usePrevious(value) {
  var ref = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(function() {
    ref.current = value;
  }, [value]);
  return ref.current;
}
function useUpdateEffect(effect, deps) {
  var mounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(function() {
    if (mounted.current) {
      effect();
    } else {
      mounted.current = true;
    }
  }, deps);
}
var useStateLogger = noop;
if (true) {
  useStateLogger = function useStateLogger2(state, DEBUG) {
    if (DEBUG === void 0) {
      DEBUG = false;
    }
    var debugRef = (0, import_react.useRef)(DEBUG);
    (0, import_react.useEffect)(function() {
      debugRef.current = DEBUG;
    }, [DEBUG]);
    (0, import_react.useEffect)(function() {
      if (debugRef.current) {
        console.group("State Updated");
        console.log("%c" + state, "font-weight: normal; font-size: 120%; font-style: italic;");
        console.groupEnd();
      }
    }, [state]);
  };
}
function wrapEvent(theirHandler, ourHandler) {
  return function(event) {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}

// ../../node_modules/@reach/descendants/dist/descendants.esm.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createDescendantContext(name, initialValue) {
  if (initialValue === void 0) {
    initialValue = {};
  }
  var descendants = [];
  return createNamedContext(name, _extends({
    descendants,
    registerDescendant: noop,
    unregisterDescendant: noop
  }, initialValue));
}
function useDescendant(descendant, context, indexProp) {
  var _useState = (0, import_react2.useState)(), forceUpdate = _useState[1];
  var _useContext = (0, import_react2.useContext)(context), registerDescendant = _useContext.registerDescendant, unregisterDescendant = _useContext.unregisterDescendant, descendants = _useContext.descendants;
  var index = indexProp !== null && indexProp !== void 0 ? indexProp : descendants.findIndex(function(item) {
    return item.element === descendant.element;
  });
  var previousDescendants = usePrevious(descendants);
  var someDescendantsHaveChanged = descendants.some(function(descendant2, index2) {
    var _previousDescendants$;
    return descendant2.element !== (previousDescendants === null || previousDescendants === void 0 ? void 0 : (_previousDescendants$ = previousDescendants[index2]) === null || _previousDescendants$ === void 0 ? void 0 : _previousDescendants$.element);
  });
  useIsomorphicLayoutEffect(function() {
    if (!descendant.element)
      forceUpdate({});
    registerDescendant(_extends({}, descendant, {
      index
    }));
    return function() {
      return unregisterDescendant(descendant.element);
    };
  }, [registerDescendant, unregisterDescendant, index, someDescendantsHaveChanged].concat(Object.values(descendant)));
  return index;
}
function useDescendantsInit() {
  return (0, import_react2.useState)([]);
}
function useDescendants(ctx) {
  return (0, import_react2.useContext)(ctx).descendants;
}
function DescendantProvider(_ref) {
  var Ctx = _ref.context, children = _ref.children, items = _ref.items, set = _ref.set;
  var registerDescendant = (0, import_react2.useCallback)(
    function(_ref2) {
      var element = _ref2.element, explicitIndex = _ref2.index, rest = _objectWithoutPropertiesLoose(_ref2, ["element", "index"]);
      if (!element) {
        return;
      }
      set(function(items2) {
        var newItems;
        if (explicitIndex != null) {
          newItems = [].concat(items2, [_extends({}, rest, {
            element,
            index: explicitIndex
          })]);
        } else if (items2.length === 0) {
          newItems = [].concat(items2, [_extends({}, rest, {
            element,
            index: 0
          })]);
        } else if (items2.find(function(item) {
          return item.element === element;
        })) {
          newItems = items2;
        } else {
          var index = items2.findIndex(function(item) {
            if (!item.element || !element) {
              return false;
            }
            return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);
          });
          var newItem = _extends({}, rest, {
            element,
            index
          });
          if (index === -1) {
            newItems = [].concat(items2, [newItem]);
          } else {
            newItems = [].concat(items2.slice(0, index), [newItem], items2.slice(index));
          }
        }
        return newItems.map(function(item, index2) {
          return _extends({}, item, {
            index: index2
          });
        });
      });
    },
    // set is a state setter initialized by the useDescendants hook.
    // We can safely ignore the lint warning here because it will not change
    // between renders.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var unregisterDescendant = (0, import_react2.useCallback)(
    function(element) {
      if (!element) {
        return;
      }
      set(function(items2) {
        return items2.filter(function(item) {
          return element !== item.element;
        });
      });
    },
    // set is a state setter initialized by the useDescendants hook.
    // We can safely ignore the lint warning here because it will not change
    // between renders.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return import_react2.default.createElement(Ctx.Provider, {
    value: (0, import_react2.useMemo)(function() {
      return {
        descendants: items,
        registerDescendant,
        unregisterDescendant
      };
    }, [items, registerDescendant, unregisterDescendant])
  }, children);
}
function useDescendantKeyDown(context, options) {
  var _useContext2 = (0, import_react2.useContext)(context), descendants = _useContext2.descendants;
  var callback = options.callback, currentIndex = options.currentIndex, filter = options.filter, _options$key = options.key, key = _options$key === void 0 ? "index" : _options$key, _options$orientation = options.orientation, orientation = _options$orientation === void 0 ? "vertical" : _options$orientation, _options$rotate = options.rotate, rotate = _options$rotate === void 0 ? true : _options$rotate, _options$rtl = options.rtl, rtl = _options$rtl === void 0 ? false : _options$rtl;
  var index = currentIndex !== null && currentIndex !== void 0 ? currentIndex : -1;
  return function handleKeyDown(event) {
    if (!["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      return;
    }
    var selectableDescendants = filter ? descendants.filter(filter) : descendants;
    if (filter) {
      index = selectableDescendants.findIndex(function(descendant) {
        return descendant.index === currentIndex;
      });
    }
    if (!selectableDescendants.length) {
      return;
    }
    function getNextOption() {
      var atBottom = index === selectableDescendants.length - 1;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[index] : selectableDescendants[(index + 1) % selectableDescendants.length];
    }
    function getPreviousOption() {
      var atTop = index === 0;
      return atTop ? rotate ? getLastOption() : selectableDescendants[index] : selectableDescendants[(index - 1 + selectableDescendants.length) % selectableDescendants.length];
    }
    function getFirstOption() {
      return selectableDescendants[0];
    }
    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }
    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }
        break;
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }
        break;
      case "PageUp":
        event.preventDefault();
        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;
      case "Home":
        event.preventDefault();
        var first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;
      case "PageDown":
        event.preventDefault();
        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;
      case "End":
        event.preventDefault();
        var last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  };
}

// ../../node_modules/@reach/auto-id/dist/auto-id.esm.js
var import_react3 = __toESM(require_react());
var serverHandoffComplete = false;
var id = 0;
var genId = function genId2() {
  return ++id;
};
var useId = function useId2(idFromProps) {
  var initialId = idFromProps || (serverHandoffComplete ? genId() : null);
  var _useState = (0, import_react3.useState)(initialId), id2 = _useState[0], setId = _useState[1];
  useIsomorphicLayoutEffect(function() {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  (0, import_react3.useEffect)(function() {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return id2 != null ? String(id2) : void 0;
};

// ../../node_modules/@reach/tabs/dist/tabs.esm.js
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var TabsDescendantsContext = createDescendantContext("TabsDescendantsContext");
var TabPanelDescendantsContext = createDescendantContext("TabPanelDescendantsContext");
var TabsContext = createNamedContext("TabsContext", {});
var TabsKeyboardActivation;
(function(TabsKeyboardActivation2) {
  TabsKeyboardActivation2["Auto"] = "auto";
  TabsKeyboardActivation2["Manual"] = "manual";
})(TabsKeyboardActivation || (TabsKeyboardActivation = {}));
var TabsOrientation;
(function(TabsOrientation2) {
  TabsOrientation2["Horizontal"] = "horizontal";
  TabsOrientation2["Vertical"] = "vertical";
})(TabsOrientation || (TabsOrientation = {}));
var Tabs = forwardRefWithAs(function Tabs2(_ref, ref) {
  var _props$id;
  var _ref$as = _ref.as, Comp = _ref$as === void 0 ? "div" : _ref$as, children = _ref.children, defaultIndex = _ref.defaultIndex, _ref$orientation = _ref.orientation, orientation = _ref$orientation === void 0 ? TabsOrientation.Horizontal : _ref$orientation, _ref$index = _ref.index, controlledIndex = _ref$index === void 0 ? void 0 : _ref$index, _ref$keyboardActivati = _ref.keyboardActivation, keyboardActivation = _ref$keyboardActivati === void 0 ? TabsKeyboardActivation.Auto : _ref$keyboardActivati, onChange = _ref.onChange, _ref$readOnly = _ref.readOnly, readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly, props = _objectWithoutPropertiesLoose2(_ref, ["as", "children", "defaultIndex", "orientation", "index", "keyboardActivation", "onChange", "readOnly"]);
  var isControlled = (0, import_react4.useRef)(controlledIndex != null);
  useControlledSwitchWarning(controlledIndex, "index", "Tabs");
  var _id = useId(props.id);
  var id2 = (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : makeId("tabs", _id);
  var userInteractedRef = (0, import_react4.useRef)(false);
  var selectedPanelRef = (0, import_react4.useRef)(null);
  var isRTL = (0, import_react4.useRef)(false);
  var _useControlledState = useControlledState(controlledIndex, defaultIndex !== null && defaultIndex !== void 0 ? defaultIndex : 0), selectedIndex = _useControlledState[0], setSelectedIndex = _useControlledState[1];
  var _useState = (0, import_react4.useState)(-1), focusedIndex = _useState[0], setFocusedIndex = _useState[1];
  var _useDescendantsInit = useDescendantsInit(), tabs = _useDescendantsInit[0], setTabs = _useDescendantsInit[1];
  var context = (0, import_react4.useMemo)(function() {
    return {
      focusedIndex,
      id: id2,
      isControlled: isControlled.current,
      isRTL,
      keyboardActivation,
      onFocusPanel: function onFocusPanel() {
        var _selectedPanelRef$cur;
        (_selectedPanelRef$cur = selectedPanelRef.current) === null || _selectedPanelRef$cur === void 0 ? void 0 : _selectedPanelRef$cur.focus();
      },
      onSelectTab: readOnly ? noop : function(index) {
        userInteractedRef.current = true;
        onChange && onChange(index);
        setSelectedIndex(index);
      },
      onSelectTabWithKeyboard: readOnly ? noop : function(index) {
        var _tabs$index$element;
        userInteractedRef.current = true;
        switch (keyboardActivation) {
          case TabsKeyboardActivation.Manual:
            (_tabs$index$element = tabs[index].element) === null || _tabs$index$element === void 0 ? void 0 : _tabs$index$element.focus();
            return;
          case TabsKeyboardActivation.Auto:
          default:
            onChange && onChange(index);
            setSelectedIndex(index);
            return;
        }
      },
      orientation,
      selectedIndex,
      selectedPanelRef,
      setFocusedIndex,
      setSelectedIndex,
      userInteractedRef
    };
  }, [focusedIndex, id2, keyboardActivation, onChange, orientation, readOnly, selectedIndex, setSelectedIndex, tabs]);
  (0, import_react4.useEffect)(function() {
    return checkStyles("tabs");
  }, []);
  return import_react4.default.createElement(DescendantProvider, {
    context: TabsDescendantsContext,
    items: tabs,
    set: setTabs
  }, import_react4.default.createElement(TabsContext.Provider, {
    value: context
  }, import_react4.default.createElement(Comp, Object.assign({}, props, {
    ref,
    "data-reach-tabs": "",
    "data-orientation": orientation,
    id: props.id
  }), isFunction(children) ? children({
    focusedIndex,
    id: id2,
    selectedIndex
  }) : children)));
});
if (true) {
  Tabs.displayName = "Tabs";
  Tabs.propTypes = {
    children: import_prop_types.default.node.isRequired,
    onChange: import_prop_types.default.func,
    orientation: import_prop_types.default.oneOf(Object.values(TabsOrientation)),
    index: function index(props, name, compName, location, propName) {
      var val = props[name];
      if (props.index > -1 && props.onChange == null && props.readOnly !== true) {
        return new Error("You provided a value prop to `" + compName + "` without an `onChange` handler. This will render a read-only tabs element. If the tabs should be mutable use `defaultIndex`. Otherwise, set `onChange`.");
      } else if (val != null && !isNumber(val)) {
        return new Error("Invalid prop `" + propName + "` supplied to `" + compName + "`. Expected `number`, received `" + (Array.isArray(val) ? "array" : typeof val) + "`.");
      }
      return null;
    },
    defaultIndex: import_prop_types.default.number
  };
}
var TabListImpl = forwardRefWithAs(function TabList(_ref2, forwardedRef) {
  var children = _ref2.children, _ref2$as = _ref2.as, Comp = _ref2$as === void 0 ? "div" : _ref2$as, onKeyDown = _ref2.onKeyDown, props = _objectWithoutPropertiesLoose2(_ref2, ["children", "as", "onKeyDown"]);
  var _useContext = (0, import_react4.useContext)(TabsContext), focusedIndex = _useContext.focusedIndex, isControlled = _useContext.isControlled, isRTL = _useContext.isRTL, keyboardActivation = _useContext.keyboardActivation, onSelectTabWithKeyboard = _useContext.onSelectTabWithKeyboard, orientation = _useContext.orientation, selectedIndex = _useContext.selectedIndex, setSelectedIndex = _useContext.setSelectedIndex;
  var tabs = useDescendants(TabsDescendantsContext);
  var ownRef = (0, import_react4.useRef)(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  (0, import_react4.useEffect)(function() {
    if (ownRef.current && (ownRef.current.ownerDocument && ownRef.current.ownerDocument.dir === "rtl" || getElementComputedStyle(ownRef.current, "direction") === "rtl")) {
      isRTL.current = true;
    }
  }, [isRTL]);
  var handleKeyDown = useEventCallback(wrapEvent(onKeyDown, useDescendantKeyDown(TabsDescendantsContext, {
    currentIndex: keyboardActivation === TabsKeyboardActivation.Manual ? focusedIndex : selectedIndex,
    orientation,
    rotate: true,
    callback: onSelectTabWithKeyboard,
    filter: function filter(tab) {
      return !tab.disabled;
    },
    rtl: isRTL.current
  })));
  useIsomorphicLayoutEffect(function() {
    var _tabs$selectedIndex;
    if (!isControlled && boolOrBoolString((_tabs$selectedIndex = tabs[selectedIndex]) === null || _tabs$selectedIndex === void 0 ? void 0 : _tabs$selectedIndex.disabled)) {
      var next = tabs.find(function(tab) {
        return !tab.disabled;
      });
      if (next) {
        setSelectedIndex(next.index);
      }
    }
  }, [tabs, isControlled, selectedIndex, setSelectedIndex]);
  return import_react4.default.createElement(
    Comp,
    Object.assign({
      // The element that serves as the container for the set of tabs has role
      // `tablist`
      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
      role: "tablist",
      "aria-orientation": orientation
    }, props, {
      "data-reach-tab-list": "",
      ref,
      onKeyDown: handleKeyDown
    }),
    import_react4.Children.map(children, function(child, index) {
      return cloneValidElement(child, {
        isSelected: index === selectedIndex
      });
    })
  );
});
if (true) {
  TabListImpl.displayName = "TabList";
  TabListImpl.propTypes = {
    as: import_prop_types.default.any,
    children: import_prop_types.default.node
  };
}
var TabList2 = memoWithAs(TabListImpl);
if (true) {
  TabList2.displayName = "TabList";
}
var Tab = forwardRefWithAs(function Tab2(_ref3, forwardedRef) {
  var children = _ref3.children, _ = _ref3.isSelected, _ref3$as = _ref3.as, Comp = _ref3$as === void 0 ? "button" : _ref3$as, indexProp = _ref3.index, disabled = _ref3.disabled, onBlur = _ref3.onBlur, onFocus = _ref3.onFocus, props = _objectWithoutPropertiesLoose2(_ref3, ["children", "isSelected", "as", "index", "disabled", "onBlur", "onFocus"]);
  var _useContext2 = (0, import_react4.useContext)(TabsContext), tabsId = _useContext2.id, onSelectTab = _useContext2.onSelectTab, orientation = _useContext2.orientation, selectedIndex = _useContext2.selectedIndex, userInteractedRef = _useContext2.userInteractedRef, setFocusedIndex = _useContext2.setFocusedIndex;
  var ownRef = (0, import_react4.useRef)(null);
  var ref = useForkedRef(forwardedRef, ownRef);
  var index = useDescendant({
    element: ownRef.current,
    disabled: !!disabled
  }, TabsDescendantsContext, indexProp);
  var htmlType = Comp === "button" && props.type == null ? "button" : props.type;
  var isSelected = index === selectedIndex;
  function onSelect() {
    onSelectTab(index);
  }
  useUpdateEffect(function() {
    if (isSelected && ownRef.current && userInteractedRef.current) {
      userInteractedRef.current = false;
      ownRef.current.focus();
    }
  }, [isSelected, userInteractedRef]);
  var handleFocus = useEventCallback(wrapEvent(onFocus, function() {
    setFocusedIndex(index);
  }));
  var handleBlur = useEventCallback(wrapEvent(onFocus, function() {
    setFocusedIndex(-1);
  }));
  return import_react4.default.createElement(
    Comp,
    Object.assign({
      "aria-controls": makeId(tabsId, "panel", index),
      "aria-disabled": disabled,
      "aria-selected": isSelected,
      // Each element that serves as a tab has role `tab` and is contained
      // within the element with role `tablist`.
      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
      role: "tab",
      tabIndex: isSelected ? 0 : -1
    }, props, {
      ref,
      "data-reach-tab": "",
      "data-orientation": orientation,
      "data-selected": isSelected ? "" : void 0,
      disabled,
      id: makeId(tabsId, "tab", index),
      onClick: onSelect,
      onFocus: handleFocus,
      onBlur: handleBlur,
      type: htmlType
    }),
    children
  );
});
if (true) {
  Tab.displayName = "Tab";
  Tab.propTypes = {
    children: import_prop_types.default.node,
    disabled: import_prop_types.default.bool
  };
}
var TabPanelsImpl = forwardRefWithAs(function TabPanels(_ref4, forwardedRef) {
  var children = _ref4.children, _ref4$as = _ref4.as, Comp = _ref4$as === void 0 ? "div" : _ref4$as, props = _objectWithoutPropertiesLoose2(_ref4, ["children", "as"]);
  var ownRef = (0, import_react4.useRef)();
  var ref = useForkedRef(ownRef, forwardedRef);
  var _useDescendantsInit2 = useDescendantsInit(), tabPanels = _useDescendantsInit2[0], setTabPanels = _useDescendantsInit2[1];
  return import_react4.default.createElement(DescendantProvider, {
    context: TabPanelDescendantsContext,
    items: tabPanels,
    set: setTabPanels
  }, import_react4.default.createElement(Comp, Object.assign({}, props, {
    ref,
    "data-reach-tab-panels": ""
  }), children));
});
if (true) {
  TabPanelsImpl.displayName = "TabPanels";
  TabPanelsImpl.propTypes = {
    as: import_prop_types.default.any,
    children: import_prop_types.default.node
  };
}
var TabPanels2 = memoWithAs(TabPanelsImpl);
if (true) {
  TabPanels2.displayName = "TabPanels";
}
var TabPanel = forwardRefWithAs(function TabPanel2(_ref5, forwardedRef) {
  var children = _ref5.children, ariaLabel = _ref5["aria-label"], _ref5$as = _ref5.as, Comp = _ref5$as === void 0 ? "div" : _ref5$as, props = _objectWithoutPropertiesLoose2(_ref5, ["children", "aria-label", "as"]);
  var _useContext3 = (0, import_react4.useContext)(TabsContext), selectedPanelRef = _useContext3.selectedPanelRef, selectedIndex = _useContext3.selectedIndex, tabsId = _useContext3.id;
  var ownRef = (0, import_react4.useRef)(null);
  var index = useDescendant({
    element: ownRef.current
  }, TabPanelDescendantsContext);
  var id2 = makeId(tabsId, "panel", index);
  var isSelected = index === selectedIndex;
  var readyToHide = (0, import_react4.useRef)(false);
  var hidden = readyToHide.current ? !isSelected : false;
  import_react4.default.useEffect(function() {
    readyToHide.current = true;
  }, []);
  var ref = useForkedRef(forwardedRef, ownRef, isSelected ? selectedPanelRef : null);
  return import_react4.default.createElement(
    Comp,
    Object.assign({
      "aria-labelledby": makeId(tabsId, "tab", index),
      hidden,
      // Each element that contains the content panel for a tab has role
      // `tabpanel`.
      // https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel
      role: "tabpanel",
      tabIndex: isSelected ? 0 : -1
    }, props, {
      ref,
      "data-reach-tab-panel": "",
      id: id2
    }),
    children
  );
});
if (true) {
  TabPanel.displayName = "TabPanel";
  TabPanel.propTypes = {
    as: import_prop_types.default.any,
    children: import_prop_types.default.node
  };
}
function useTabsContext() {
  var _useContext4 = (0, import_react4.useContext)(TabsContext), focusedIndex = _useContext4.focusedIndex, id2 = _useContext4.id, selectedIndex = _useContext4.selectedIndex;
  return (0, import_react4.useMemo)(function() {
    return {
      focusedIndex,
      id: id2,
      selectedIndex
    };
  }, [focusedIndex, id2, selectedIndex]);
}
export {
  Tab,
  TabList2 as TabList,
  TabPanel,
  TabPanels2 as TabPanels,
  Tabs,
  TabsKeyboardActivation,
  TabsOrientation,
  useTabsContext
};
//# sourceMappingURL=@reach_tabs.js.map
